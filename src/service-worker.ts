/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

// `build` is an array of all the files generated by the bundler
// `files` is an array of everything in the `static` directory
// `version` is the current version of the app

const worker = self as unknown as ServiceWorkerGlobalScope;
const STATIC_CACHE_NAME = `cache-static-${version}`;
const APP_CACHE_NAME = `cache-app-${version}`;

const routes = ['/'];

const addDomain = (assets: string[]) => assets.map((f) => self.location.origin + f);

const assets = new Set(addDomain([...files, ...build, ...routes]));

// Cache all the static assets
worker.addEventListener('install', (event) => {
	console.debug('[ServiceWorker] install');

	event.waitUntil(
		(async () => {
			const cache = await caches.open(STATIC_CACHE_NAME);
			console.debug('[ServiceWorker] pre-caching');
			await cache.addAll(assets);
		})()
	);

	worker.skipWaiting();
});

// Clean up old caches
worker.addEventListener('activate', (event) => {
	console.debug('[ServiceWorker] activate');

	event.waitUntil(
		(async () => {
			const cacheNames = await caches.keys();

			await Promise.all(
				cacheNames
					.filter((name) => name !== STATIC_CACHE_NAME && name !== APP_CACHE_NAME)
					.map((name) => {
						console.debug('[ServiceWorker] removing old cache', name);
						return caches.delete(name);
					})
			);
		})()
	);

	// Tell the active service worker to take control of the page immediately
	worker.clients.claim();
});

// Fetch and cache resources
worker.addEventListener('fetch', (event) => {
	const { request } = event;

	// Do not cache non GET and non HTTP requests
	if (request.method !== 'GET' || !/^https?:\/\//.test(request.url)) {
		event.respondWith(fetch(request));
		return;
	}

	// Cache first for images, fonts and static assets
	if (/\.(?:png|jpg|jpeg|svg|gif|woff|woff2|ttf)$/.test(request.url) || assets.has(request.url)) {
		event.respondWith(
			(async () => {
				const cache = await caches.open(STATIC_CACHE_NAME);
				const cachedResponse = await cache.match(request);

				if (cachedResponse) {
					console.debug('[Service Woker] cache hit', request.url);
					return cachedResponse;
				}

				const response = await fetch(request);
				console.log('[Service worker] caching response', request.url);
				await cache.put(request, response.clone());
				return response;
			})()
		);
		return;
	}

	// Network first, fall back to the cache
	event.respondWith(
		(async () => {
			try {
				const response = await fetch(request);

				// Cache the response
				console.debug('[ServiceWorker] caching response', request.url);
				const cache = await caches.open(APP_CACHE_NAME);
				cache.put(request, response.clone());

				return response;
			} catch (error) {
				console.debug('[ServiceWorker] network request failed, trying cache');

				const cachedResponse = await caches.match(request);

				if (cachedResponse) {
					console.debug('[ServiceWorker] cache hit', request.url);
					return cachedResponse;
				}

				// TODO: return a custom offline page
				console.debug('[ServiceWorker] cache miss, throwing error');

				throw error;
			}
		})()
	);
});
