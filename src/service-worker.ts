/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

// `build` is an array of all the files generated by the bundler
// `files` is an array of everything in the `static` directory
// `version` is the current version of the app

const worker = (self as unknown) as ServiceWorkerGlobalScope;
const STATIC_CACHE_NAME = `cache-static-${version}`;
const APP_CACHE_NAME = `cache-app-${version}`;

const routes = ['/'];

const addDomain = (assets: string[]) =>
  assets.map((f) => self.location.origin + f);

const assets = addDomain([
  ...files,
  ...build,
  ...routes,
]);

const toCache = new Set(assets);

// Cache all the static assets.
worker.addEventListener('install', (event) => {
  console.log('[ServiceWorker] install');

  event.waitUntil((async () => {
    const cache = await caches.open(STATIC_CACHE_NAME);
    console.log('[ServiceWorker] pre-caching');
    await cache.addAll(toCache);
  })());

  worker.skipWaiting();
});

// Clean up old caches.
worker.addEventListener('activate', (event) => {
  console.log('[ServiceWorker] activate');

  event.waitUntil(
    (async () => {
      const cacheNames = await caches.keys();

      await Promise.all(
        cacheNames
          .filter((name) => name !== STATIC_CACHE_NAME && name !== APP_CACHE_NAME)
          .map((name) => {
            console.log('[ServiceWorker] removing old cache', name);
            return caches.delete(name);
          })
      );
    })()
  );

  // tell the active service worker to take control of the page immediately
  worker.clients.claim();
});

// Fetch and cache resources.
worker.addEventListener('fetch', (event) => {
  const { request } = event;

  // do not cache non-GET requests
  if (request.method !== 'GET') {
    event.respondWith(fetch(request));
    return;
  }

  // try the network first, falling back to the cache
  event.respondWith(
    (async () => {
      try {
        const response = await fetch(request);

        // cache the response
        console.log('[ServiceWorker] caching', request.url);
        const cache = await caches.open(APP_CACHE_NAME);
        cache.put(request, response.clone());

        return response;
      }
      catch (error) {
        console.log('[ServiceWorker] network request failed, trying cache');

        const cached = await caches.match(request);

        if (cached) {
          console.log('[ServiceWorker] cache hit');
          return cached;
        }

        // TODO: return a custom offline page
        console.log('[ServiceWorker] cache miss, throwing error');

        throw error;
      }
    })()
  );
});
