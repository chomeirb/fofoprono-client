/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

// `build` is an array of all the files generated by the bundler
// `files` is an array of everything in the `static` directory
// `version` is the current version of the app

const worker = self as unknown as ServiceWorkerGlobalScope;
const STATIC_CACHE_NAME = `cache-static-${version}`;
const APP_CACHE_NAME = `cache-app-${version}`;

const routes = ['/'];

const addDomain = (assets: string[]) => assets.map((f) => self.location.origin + f);

const assets = addDomain([...files, ...build, ...routes]);

const toCache = new Set(assets);

// Cache all the static assets.
worker.addEventListener('install', (event) => {
	console.debug('[ServiceWorker] install');

	event.waitUntil(
		(async () => {
			const cache = await caches.open(STATIC_CACHE_NAME);
			console.debug('[ServiceWorker] pre-caching');
			await cache.addAll(toCache);
		})()
	);

	worker.skipWaiting();
});

// Clean up old caches.
worker.addEventListener('activate', (event) => {
	console.debug('[ServiceWorker] activate');

	event.waitUntil(
		(async () => {
			const cacheNames = await caches.keys();

			await Promise.all(
				cacheNames
					.filter((name) => name !== STATIC_CACHE_NAME && name !== APP_CACHE_NAME)
					.map((name) => {
						console.debug('[ServiceWorker] removing old cache', name);
						return caches.delete(name);
					})
			);
		})()
	);

	// tell the active service worker to take control of the page immediately
	worker.clients.claim();
});

// Fetch and cache resources.
worker.addEventListener('fetch', (event) => {
	const { request } = event;

	// do not cache non-GET requests
	if (request.method !== 'GET') {
		event.respondWith(fetch(request));
		return;
	}

	// cache images and fonts
	if (request.url.match(/\.(?:png|jpg|jpeg|svg|gif|woff|woff2|ttf)$/)) {
		event.respondWith(
			(async () => {
				const cache = await caches.open(STATIC_CACHE_NAME);
				const cachedResponse = await cache.match(request);

				if (cachedResponse) {
					console.debug('[Service Woker] cache hit', request.url);
					return cachedResponse;
				}

				const response = await fetch(request);
				console.log('[Service worker] caching response', request.url);
				await cache.put(request, response.clone());
				return response;
			})()
		);
		return;
	}

	// try the network first, fall back to the cache
	event.respondWith(
		(async () => {
			try {
				const response = await fetch(request);

				// cache the response
				console.debug('[ServiceWorker] caching response', request.url);
				const cache = await caches.open(APP_CACHE_NAME);
				cache.put(request, response.clone());

				return response;
			}
			catch (error) {
				console.debug('[ServiceWorker] network request failed, trying cache');

				const cachedResponse = await caches.match(request);

				if (cachedResponse) {
					console.debug('[ServiceWorker] cache hit', request.url);
					return cachedResponse;
				}

				// TODO: return a custom offline page
				console.debug('[ServiceWorker] cache miss, throwing error');

				throw error;
			}
		})()
	);
});
